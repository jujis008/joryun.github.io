{"meta":{"title":"Joryun's Blog","subtitle":"在最好的年纪做最对的事","description":"TO BE IS TO DO","author":"刘家源","url":"http://joryun.com"},"pages":[{"title":"ABOUT","date":"2017-05-11T09:46:38.000Z","updated":"2017-05-27T02:17:11.000Z","comments":true,"path":"about/index.html","permalink":"http://joryun.com/about/index.html","excerpt":"","text":"一路上，会偶遇很多人，生活需要游戏，但不能游戏人生；人生的道路上，如果懂得体谅，懂得宽容，日子就会很温馨，也会很安宁。每天早上以微笑开始，并且要坚持到这一天过去。 关于我 在校程序猿一枚… 爱编程，爱音乐，爱运动"},{"title":"Instagram","date":"2017-05-12T09:03:26.000Z","updated":"2017-05-12T09:03:26.000Z","comments":true,"path":"instagram/index.html","permalink":"http://joryun.com/instagram/index.html","excerpt":"","text":"jQuery(function($) { $('.instagram').on('willLoadInstagram', function(event, options) { console.log(options); }); $('.instagram').on('didLoadInstagram', function(event, response) { console.log(response); }); $('.instagram').instagram({ hash: 'perfect', clientId: '3ade0267f8cc474fa53686aa6f7a8db5' }); });"},{"title":"","date":"2017-05-27T02:24:58.000Z","updated":"2017-05-27T02:29:42.000Z","comments":false,"path":"categories/index.html","permalink":"http://joryun.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-27T02:23:18.000Z","updated":"2017-05-27T02:29:14.000Z","comments":false,"path":"tags/index.html","permalink":"http://joryun.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java8：Lambda表达式","slug":"java8-lambda","date":"2017-09-18T03:52:58.000Z","updated":"2017-09-18T03:55:24.000Z","comments":true,"path":"2017/09/18/java8-lambda/","link":"","permalink":"http://joryun.com/2017/09/18/java8-lambda/","excerpt":"","text":"为什么java还在变？“要么改变，要么衰亡”。有变化改进，并适应编程语言生态系统的气候，才能不被淘汰。语言需要不断改进以跟进硬件的更新或满足程序的期待，java必须添加新功能来改进，并且只有新功能被人使用，变化才有意义。自java8出现以来，lambda是最重要的特性之一，它可以让我们用简洁流畅的代码完成一个功能。很长一段时间，java被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行，java8中也引入了这种编程风格。在此之前我们会用匿名内部类干这些事，但这并不是好的做法！ Lambda为一等公民？我们注意到，编程语言的整个目的在于操作值，而这些值均称被为一等值(或一等公民)。编程语言中的其他结构也有助于我们表示值的结构，但在程序执行期间并不能传递，因而被称为二等公民。此时，Java8的设计者实践发现，让方法等概念作为一等值可以扩充程序员的工具库，从而引入运行时可传递方法的概念。接着，lambda登场了。 何为Lambda?简单理解，lambda表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为。 在什么地方使用Lambda表达式？可以在函数式的接口上使用Lambda表达式。 何为函数式接口？ 函数式接口就是只定义一个抽象方法的接口。比如： 1234567891011public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125;public interface Runnable &#123; public abstract void run();&#125;public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; lambda表达式可以让你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例。你也可以用匿名内部类完成同样的事，只不过比较笨拙。 @FunctionInterface此注解用于表示该接口会被设计为一个函数式接口，如果使用此注解但是接口中超过一个抽象方法，编译器将会返回一个提示原因的错误。 推开Lambda大门基础语法在lambda中我们遵循如下的表达式来编写：1(parameter) -&gt; expression 或者 (parameter) -&gt; &#123;statement;&#125; parameter:：参数列表。可为空，可为一个变量，也可以是多个变量。 expression：表达式。代码逻辑部分,是一行代码。 statement：代码片段。 Java中lambda表达式的格式：参数、箭头、主体(即表达式)。当一个动作实现无法用一行代码完成时，可以编写一段代码用 {} 包裹起来。如：1int sum = (x, y) -&gt; x + y; 这时候我们应该思考这段代码不是之前的x和y数字相加，而是创建了一个函数，用来计算两个操作数的和。后面用int类型进行接收，在lambda中为我们省略去了return(lambda已经隐式包含了return语句，也可以采用显式返回语句)。 使用函数式接口java8已经在java.util.function中定义了一套常用的函数式接口，来应用不同的lambda表达式。 Predicate 函数描述符为 (T) -&gt; boolean Consumer 函数描述符为 (T) -&gt; void Funciton 函数描述符为 (T) -&gt; R Supplier 函数描述符为 () -&gt; T UnaryOperator 函数描述符为 (T) -&gt; T BinaryOperator 函数描述符为 (T, T) -&gt; T BiPredicate 函数描述符为 (T, U) -&gt; boolean BiConsumer 函数描述符为 (T, U) -&gt; void BiFunction 函数描述符为 (T, U) -&gt; R IDEA查看函数式接口如下： 大致分类： 消费型接口示例123456public static void donation(Integer money, Consumer&lt;Integer&gt; consumer)&#123; consumer.accept(money); &#125;public static void main(String[] args) &#123; donation(1000, money -&gt; System.out.println(\"好心的麦乐迪为Blade捐赠了\"+money+\"元\")) ;&#125; 供给型接口示例12345678910public static List&lt;Integer&gt; supply(Integer num, Supplier&lt;Integer&gt; supplier)&#123; List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;() ; for(int x=0;x&lt;num;x++) resultList.add(supplier.get()); return resultList ;&#125;public static void main(String[] args) &#123; List&lt;Integer&gt; list = supply(10,() -&gt; (int)(Math.random()*100)); list.forEach(System.out::println);&#125; 函数型接口示例转换字符串为Integer123456public static Integer convert(String str, Function&lt;String, Integer&gt; function) &#123; return function.apply(str);&#125;public static void main(String[] args) &#123; Integer value = convert(\"28\", x -&gt; Integer.parseInt(x));&#125; 断言型接口示例筛选出只有2个字的水果1234567891011121314public static List&lt;String&gt; filter(List&lt;String&gt; fruit, Predicate&lt;String&gt; predicate)&#123; List&lt;String&gt; f = new ArrayList&lt;&gt;(); for (String s : fruit) &#123; if(predicate.test(s))&#123; f.add(s); &#125; &#125; return f;&#125;public static void main(String[] args) &#123; List&lt;String&gt; fruit = Arrays.asList(\"香蕉\", \"哈密瓜\", \"榴莲\", \"火龙果\", \"水蜜桃\"); List&lt;String&gt; newFruit = filter(fruit, (f) -&gt; f.length() == 2); System.out.println(newFruit);&#125; 理解示例编写一个函数式接口，输入一个年龄，判断这个人是否是成人。 123456789101112131415161718192021public class FunctionInterfaceDemo &#123; @FunctionalInterface interface Predicate&lt;T&gt; &#123; boolean test(T t); &#125; /** * 执行Predicate判断 * * @param age 年龄 * @param predicate Predicate函数式接口 * @return 返回布尔类型结果 */ public static boolean doPredicate(int age, Predicate&lt;Integer&gt; predicate) &#123; return predicate.test(age); &#125; public static void main(String[] args) &#123; boolean isAdult = doPredicate(20, x -&gt; x &gt;= 18); System.out.println(isAdult); &#125;&#125; 从这个例子我们很轻松的完成 是否是成人 的动作，其次判断是否是成人，在此之前我们的做法一般是编写一个 判断是否是成人 的方法，是无法将 判断 共用的。而在本例，你要做的是将 行为 (判断是否是成人，或者是判断是否大于30岁)传递进去，函数式接口即告诉你结果是什么。 学习文档Lambda官方文档：https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html Lambda中文文档：https://zhouyinyan.gitbooks.io/java8/content/","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://joryun.com/tags/java8/"}]},{"title":"谈谈Java对象序列化","slug":"java-object-serialization","date":"2017-05-28T01:17:58.000Z","updated":"2017-05-28T09:36:20.000Z","comments":true,"path":"2017/05/28/java-object-serialization/","link":"","permalink":"http://joryun.com/2017/05/28/java-object-serialization/","excerpt":"前言创建对象时，只要我们需要，便会一直存在。而若是程序终止，那无论如何它都不会继续存在。但某些情况下，如果对象能够在程序不运行时仍能保存其信息，那将非常有用。这样，在下次运行程序时，该对象将被重建并且拥有的信息与在程序上次运行时它所拥有的信息相同。此时，对象序列化便隆重登场了…","text":"前言创建对象时，只要我们需要，便会一直存在。而若是程序终止，那无论如何它都不会继续存在。但某些情况下，如果对象能够在程序不运行时仍能保存其信息，那将非常有用。这样，在下次运行程序时，该对象将被重建并且拥有的信息与在程序上次运行时它所拥有的信息相同。此时，对象序列化便隆重登场了… 关于对象序列化当我们在内存中创建可复用的Java对象时，一般情况下会依赖于JVM的生命周期，即会随着JVM的停止而销毁。但Java对象序列化可实现JVM停止运行之后保存(持久化)指定的对象，并可随时读取该对象。 引用《Thinking in Java》里面的一段话：利用它(对象序列化)可以实现轻量级持久性，“持久性”意味着一个对象的生存周期并不取决于程序是否正在执行；它可生存于程序的调用之间。 解析对象序列化序列化分为两部分：序列化 和 反序列化 。 序列化：将数据分解成字节流，以便在文件或网络上传输。(即 Java Object 转成 byte[] ) 反序列化：打开字节流并重构对象，从而取出对象。(即 byte[] 转成 Java Object ) 一般用途1231. 将内存中的对象状态保存至文件或数据库2. 网络传输3. Java远程方法调用(RMI) 具体实例(一)将对象状态保存至文件或数据库实现 java.io.Serializable 接口12345678910File file = new File(\"person.out\"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); //创建一个写入指定OutputStream的ObjectOutputStream对象Person person = new Person(\"Hello\", 101, Gender.MALE); out.writeObject(person); //将指定的对象写入out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); Object newPerson = in.readObject(); //从ObjectInputStream读取对象in.close(); System.out.println(newPerson); 分析：上述是网上常见的一个例子，非常简单。实现 Serializable 接口采用的是默认序列化机制，我们注意到以上例子使用了两个类 ObjectOutputStream 、ObjectInputStream ，该demo就是使用了 ObjectOutputStream 来持久化对象，而使用 ObjectInputStream 从文件中取出对象。 123影响序列化的因素：transient关键字(1) 当某个字段被声明为transient后，默认序列化机制就会忽略该字段。(2) 若是想运用其它方法来序列化这个标了transient的字段，则可以通过添加两个方法：writeObject()与readObject()。 实现 java.io. Externalizable 接口JDK中提供了另一个序列化接口——Externalizable ， Externalizable 继承于 Serializable ，序列化的细节需要程序员完成。使用该接口之后，之前基于 Serializable 接口的序列化机制就将失效。 123456789@Override public void writeExternal(ObjectOutput out) throws IOException &#123; &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; &#125; (二)使用 Protostuff 序列化库在开发项目中，序列化是经常需要处理的问题。不管是网络传输上用json、xml、对象序列化，还是缓存数据中的序列化，都是相当重要的。 前提以并发系统为例，使用 Redis 缓存存储数据时，若单单只使用JDK的序列化，效率会很低，对并发类系统造成的影响无法想象。而Google开发的一套序列化方案 Protostuff ，好处很多，独立于语言，独立于平台，重要的是效率相当高，使用 Protostuff 序列化后的字节大小是json的10分之一，xml的20分之一，是二进制序列化的10分之一。 目的以实际的并发系统为例，使用 Protostuff 框架进行序列化处理。 说明 开发环境：IDEA，Tomcat 软件环境：SpringMVC，Spring，MyBatis 模块描述：若缓存中有我们需要的对象，则取出来；若是没有，则存入缓存中( Redis ) 过程 序列化 1set Object() -&gt; 序列化 -&gt; byte[] 反序列化 1get -&gt; byte[] -&gt; 反序列化 -&gt; Object() 编码Maven引入 Protostuff123456789101112&lt;!-- protostuff序列化依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt; &lt;version&gt;1.0.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt; &lt;version&gt;1.0.8&lt;/version&gt; &lt;/dependency&gt; 在Dao层缓存RedisDao中引入 Protostuffset Object() -&gt; 序列化 -&gt; byte[] 1234567//LinkedBuffer：缓存器byte[] bytes = ProtobufIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));//超时缓存int timeout = 60 * 60; //1小时String result = jedis.setex(key.getBytes(), timeout, bytes); get -&gt; byte[] -&gt; 反序列化 -&gt; Object() 123456789byte[] bytes = jedis.get(key.getBytes());//从缓存获取到if (bytes != null) &#123; //空对象 Seckill seckill = schema.newMessage(); ProtobufIOUtil.mergeFrom(bytes, seckill, schema); return seckill;&#125; 测试 结果表明，字节数被压缩得极小，在并发系统效率确实不错，很值得学习的一个序列化库！ 总结本博文的内容均为自己的总结，想深入学习的朋友可参考《Thinking in Java》和《Effective Java》，里面写的内容非常详细的。共勉！！ 编程是一门事业。互励共勉！！！ Github：Joryun’s Github CSDN：Joryun’s CSDN 个人网站：Joryun’s Website","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"序列化","slug":"序列化","permalink":"http://joryun.com/tags/序列化/"},{"name":"对象","slug":"对象","permalink":"http://joryun.com/tags/对象/"}]},{"title":"Java奇技淫巧之普通web项目转换为Maven项目","slug":"web-convert-maven","date":"2017-05-21T09:24:50.000Z","updated":"2017-05-28T02:58:41.000Z","comments":true,"path":"2017/05/21/web-convert-maven/","link":"","permalink":"http://joryun.com/2017/05/21/web-convert-maven/","excerpt":"前言网上有许多普通web项目转换为maven项目的博文，但由于项目的不同，所需的步骤及必须的转换步骤也不同。因此，本文章将以一个基于SpringMVC，Spring，Hibernate的商城项目为例，详述转换过程。 具体实例说明 开发环境：IDEA，MySQL 项目构建：暂无（已通过本文章成功转换为maven） 软件环境：SpringMVC，Spring，Hibernate 项目描述：商城系统 目的将普通Dynamic Web项目转换为Maven项目","text":"前言网上有许多普通web项目转换为maven项目的博文，但由于项目的不同，所需的步骤及必须的转换步骤也不同。因此，本文章将以一个基于SpringMVC，Spring，Hibernate的商城项目为例，详述转换过程。 具体实例说明 开发环境：IDEA，MySQL 项目构建：暂无（已通过本文章成功转换为maven） 软件环境：SpringMVC，Spring，Hibernate 项目描述：商城系统 目的将普通Dynamic Web项目转换为Maven项目 步骤前提转换之前将项目置于Github上，并clone到IDEA上，防止最后不成功而导致项目bug难以补救，毕竟git的revision功能相当棒呢！！ 1. 将项目初步convert为Maven项目选择 Add framework support ，并勾选导入“Maven”依赖 2. 备份lib接着移除lib，然后编写pom.xml看到下面的一大片“红”，勿担心，那只是你“颠覆世界”的第一步，千万不能退缩 接着备份lib，再移除项目的lib，将项目置于“空jar”状态 补充pom.xml的头，自动生成的会略掉好几项必须的配置 12345678&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.shop&lt;/groupId&gt; &lt;artifactId&gt;Shop&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;Shop Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; 接着是个体力活，进入每个java、properties、xml、jsp等文件使用Add Maven依赖方式自动导入（快捷键： alt+enter），当然前提是网速要好哈！ 经过上步，已经初步导入了大部份必需的依赖，接着，将一些其它依赖（可参考之前备份的lib）随之导入，千万别忽略这一步，因为类似 mysql-connector-java 等这些依赖一般是还未导入的！ 3. 将spring配置文件、数据库属性文件、日志配置文件等剪切至src/main/resources之下 若是里面配置文件的映射路径有差错，记得进入改正，idea下cmd+鼠标可测试大部份不正确的路径。 4.将原来放置在WebRoot路径下的文件（包括js，css，jsp等）都剪切至webapp文件夹之下，并删除WebRoot文件夹重要的是 WEB-INF 文件夹 5.重新部署并测试重新部署至 Tomcat（或Jetty） 测试效果。 基本上，到这一步离成功也就不远了（而我已经成功了）。若是…若是还有bug，多调调，看看日志，看看控制台输出，直至转换成功也不失为一次很棒的尝试。 若有不明白的参见商城系统：Shop 总结Maven是一套相当不错的软件项目管理工具，因此很多程序猿可能会频频遇到Dynamic Web项目转换Maven项目的情况，这时大家便可以学习起来，以备不时之需！共勉！！ 编程是一门事业。互励共勉！！！ Github：Joryun’s Github CSDN：Joryun’s CSDN 个人网站：Joryun’s Website","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"maven","slug":"maven","permalink":"http://joryun.com/tags/maven/"}]},{"title":"Spring全家桶:(1)Spring JMS + ActiveMQ起步","slug":"spring-jms-activemq-start","date":"2017-05-21T03:46:40.000Z","updated":"2017-05-28T02:53:02.000Z","comments":true,"path":"2017/05/21/spring-jms-activemq-start/","link":"","permalink":"http://joryun.com/2017/05/21/spring-jms-activemq-start/","excerpt":"前言说明开发环境：IDEA，Active MQ 项目构建：Maven 软件环境：Spring，Spring JMS，Active MQ 项目描述：Spring JMS与Active MQ进行通讯 目的入门Spring JMS、Active MQ，使用Spring JMS向Active MQ的Message Queue发消息和读消息。","text":"前言说明开发环境：IDEA，Active MQ 项目构建：Maven 软件环境：Spring，Spring JMS，Active MQ 项目描述：Spring JMS与Active MQ进行通讯 目的入门Spring JMS、Active MQ，使用Spring JMS向Active MQ的Message Queue发消息和读消息。 123PS：demo整合过程均亲测，按顺序编码已测试通过项目代码有注释，可供理清各个class和各个方法块及属性的作用。 编码1. 开启Active MQ服务 2. 使用maven导入依赖库pom.xml 123456789101112131415161718192021222324252627282930313233343536&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt; &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt; &lt;version&gt;3.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 创建application.properties，封装Message Queue的配置application.properties 12jms.broker.url=tcp://localhost:61616jms.queue.name=bar 4. JMS全局配置，配置与ActiveMQ的连接JMSConfiguration.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.8.0.xsd\"&gt; &lt;!-- 配置与ActiveMQ的连接 --&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"location\"&gt; &lt;value&gt;application.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- Activemq connection factory --&gt; &lt;bean id=\"amqConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;constructor-arg index=\"0\" value=\"$&#123;jms.broker.url&#125;\" /&gt; &lt;property name=\"useAsyncSend\" value=\"true\" /&gt; &lt;/bean&gt; &lt;!-- ConnectionFactory Definition --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.CachingConnectionFactory\"&gt; &lt;constructor-arg ref=\"amqConnectionFactory\" /&gt; &lt;/bean&gt; &lt;!-- Default Destination Queue Definition--&gt; &lt;bean id=\"defaultDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg index=\"0\" value=\"$&#123;jms.queue.name&#125;\" /&gt; &lt;/bean&gt; &lt;!-- JmsTemplate Definition --&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;property name=\"defaultDestination\" ref=\"defaultDestination\"/&gt; &lt;/bean&gt; &lt;!-- Message Sender Definition --&gt; &lt;bean id=\"messageSender\" class=\"com.net.jms.MessageSender\"&gt; &lt;constructor-arg index=\"0\" ref=\"jmsTemplate\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 分析： （1） 配置ActiveMQ提供的ActiveMQConnectionFactory （2） 配置一个Spring JMS提供的CachingConnectionFactory （3） 定义一个ActiveMQ Queue作为消息的接收Queue（即Destination） （4） 创建JmsTemplate （5） 自定义一个MessageSender，使用该JmsTemplate进行消息发送 5. 创建MessageSender，提供发送消息的服务MessageSender.java 123456789101112131415161718192021222324package com.net.jms;import org.springframework.jms.core.JmsTemplate;import org.springframework.stereotype.Component;/** * 发送消息的服务：发送字符串信息 */@Componentpublic class MessageSender &#123; private final JmsTemplate jmsTemplate; public MessageSender(JmsTemplate jmsTemplate) &#123; this.jmsTemplate = jmsTemplate; &#125; public void send(final String text) &#123; jmsTemplate.convertAndSend(text); System.out.println(\"send: \" + text); &#125;&#125; 作用：通过jmsTemplate发送一个字符串信息 6. 配置一个Listener来监听和处理当前的Message QueueJMSReceiver.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置一个Listener来监听和处理当前的Message Queue --&gt; &lt;!-- Message Receiver Definition --&gt; &lt;bean id=\"messageReceiver\" class=\"com.net.jms.MessageReceiver\" /&gt; &lt;bean class=\"org.springframework.jms.listener.SimpleMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;property name=\"destinationName\" value=\"$&#123;jms.queue.name&#125;\"/&gt; &lt;property name=\"messageListener\" ref=\"messageReceiver\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 自定义了一个MessageListener，且使用Spring提供的SimpleMessageListenerContainer作为Container。 7. 创建MessageListener的具体实现MessageReceiver.java 12345678910111213141516171819202122232425262728293031323334package com.net.jms;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;/** * 消息侦听器：监听当前的Message Queue * 从Queue中读取消息，并输出到当前控制台中 */public class MessageReceiver implements MessageListener &#123; public void onMessage(Message message) &#123; if (message instanceof TextMessage)&#123; TextMessage textMessage = (TextMessage) message; try &#123; String text = textMessage.getText(); System.out.println(String.format(\"Received: %s\",text)); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; catch (JMSException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 作用：从Queue中读取消息，并输出到当前控制台中。 8. 创建两个测试类，一个用于发送消息到ActiveMQ的MessageQueue中，一个用于从MessageQueue中读取消息SenderApp.java 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.net;import com.net.jms.MessageSender;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.util.StringUtils;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;/** * 发送消息到ActiveMQ的Message Queue */public class SenderApp &#123; public static void main(String[] args) throws IOException &#123; start(\"JMSConfiguration.xml\"); &#125; public static void start(String configLocation) throws IOException &#123; MessageSender sender = getMessageSender(configLocation); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"Please input your message:\"); String text = br.readLine(); while (!StringUtils.isEmpty(text)) &#123; System.out.println(String.format(\"send message: %s\", text)); sender.send(text); text = br.readLine(); &#125; &#125; public static MessageSender getMessageSender(String configLocation) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(configLocation); return (MessageSender) context.getBean(\"messageSender\"); &#125;&#125; ReceiverApp.java 123456789101112131415package com.net;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 从Message Queue中读取消息 */public class ReceiverApp &#123; public static void main(String[] args) &#123; new ClassPathXmlApplicationContext(\"JMSConfiguration.xml\", \"JMSReceiver.xml\"); &#125;&#125; 9. 测试：运行SenderApp.java，在控制台输入消息，接着运行ReceiverApp.java，结果如下 总结到此，spring jms与activemq的通信就已经集成结束了。共勉！！！ 编程是一门事业。互励共勉！！！ Github：Joryun’s Github CSDN：Joryun’s CSDN 个人网站：Joryun’s Website","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://joryun.com/tags/spring/"},{"name":"jms","slug":"jms","permalink":"http://joryun.com/tags/jms/"},{"name":"avtivemq","slug":"avtivemq","permalink":"http://joryun.com/tags/avtivemq/"}]},{"title":"Think in Java:(1)对象篇","slug":"think-in-java-01","date":"2017-05-09T15:56:18.000Z","updated":"2017-05-28T02:35:25.000Z","comments":true,"path":"2017/05/09/think-in-java-01/","link":"","permalink":"http://joryun.com/2017/05/09/think-in-java-01/","excerpt":"前言略读了一些内容，觉得还是不太适合初学者入门，倒适合一开始偏向于项目而后想回头重新拾回Java点点滴滴的猿们。以下总结的都是一些博主觉得有意思的解释，或者忘却了的知识点。正在学习或者已经读完的朋友们，互勉！！！","text":"前言略读了一些内容，觉得还是不太适合初学者入门，倒适合一开始偏向于项目而后想回头重新拾回Java点点滴滴的猿们。以下总结的都是一些博主觉得有意思的解释，或者忘却了的知识点。正在学习或者已经读完的朋友们，互勉！！！ 笔记1. 基类 导出类使基类与导出类产生差异的两种方法： 直接在导出类添加新方法 改变现有基类方法的行为，即覆盖 2. OOP “后期绑定” OOP中，程序直到运行时才能够确定代码的地址，所以当消息发送到一个泛化对象时，必须采用其它机制——后期绑定。 后期绑定：当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查，但并不知道将被执行的确切代码。 3. 向上转型将导出类看做是它的基类的过程称为向上转型。 4. 单根继承结构的优点 保证所有对象都具备某些功能 解释：单根继承结构中的所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类型。 使垃圾回收器的实现变得容易许多 解释：由于所有对象都保证具有其类型信息，因此回收器不会因无法确定对象的类型而陷入僵局。这对于系统级操作（如异常处理）显得尤其重要。 5. 参数化类型 参数化类型：是一个编译器可以自动定制作用于特定类型上的类。 Java SE5的重大变化之一就是增加了参数化类型，即泛型（in Java）。 6. 线程的基本解释通常，线程只是一种为单一处理器分配执行时间的手段。 7. 引用操纵对象一旦创建了一个引用，可使用new操作符实现与一个对象相关联。 8. 数据存储在什么地方 寄存器 这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但寄存器的数量极其有限，所以寄存器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。 堆栈 位于通用RAM（随机访问存储器）中，但通过堆栈指针可从处理器那里获得直接支持，堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存，这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储于堆栈中——特别是对象引用，但是Java对象并不存储于其中。 堆 一种通用的内存池（也位于RAM区），用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当需要一个对象时，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配，当然， 为这种灵活性必须付出相应的代价：用堆进行存储分配和清理可能比堆栈进行分配存储需要更多的时间。 非RAM存储 如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是流对象和持久化对象。在流对象中，对象转化成字节流，通常被发送给另一台机器。在持久化对象中，对象被存放于磁盘上，因此，即使程序终止，它们仍可以保持自己的状态。这种存储方式的技巧在于：把对象转化成可以存放在其他媒介上的事物，在需要时，可恢复成常规的、基于RAM的对象。 9. 包装器类Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类。 10. 对象的作用域Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。如： 123&#123; String s = new String(\"a String\");&#125; // End of scope 引用s在作用域终点就消失了。但s指向的String对象仍继续占据内存空间。 11. 初始化若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它获得一个默认值。 注：确实初始化的方法不适用于局部变量。因此，若在某个方法内定义，则得到的可能是任意值，而不会被自动初始化为0。 12. “向前引用”某个类在发出调用的源文件中，而此时即可直接使用这个类，即使这个类在文件的后面才被定义（Java消除了所谓“向前引用”的问题）。 13. static尽管当static作用于某个字段时，肯定会改变数据创建的方式（因为一个static字段对每个类来说都只有一份存储空间，而非static字段则是对每个对象都有一个存储空间），但是如果static作用于某个方法，差别却没有那么大。static方法的一个重要用法就是在不创建任何对象的前提下就可以调用它。 编程是一门事业。互励共勉！！！ Github：Joryun’s Github CSDN：Joryun’s CSDN 个人网站：Joryun’s Website","categories":[{"name":"Learning","slug":"Learning","permalink":"http://joryun.com/categories/Learning/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"thinking-in-java","slug":"thinking-in-java","permalink":"http://joryun.com/tags/thinking-in-java/"}]},{"title":"webservice:(2)体验查询号码归属地demo","slug":"webservice-demo","date":"2017-04-15T13:48:04.000Z","updated":"2017-05-28T08:58:37.000Z","comments":true,"path":"2017/04/15/webservice-demo/","link":"","permalink":"http://joryun.com/2017/04/15/webservice-demo/","excerpt":"前言对于webservice的介绍，本文就不再赘余讲述。详见文章 webservice:(1)新手搭建调用webservice那些坑 首先，先给出一个站点，该站点提供了许多webservice服务，可供调用测试。站点： http://www.webxml.com.cn/zh_cn/index.aspx","text":"前言对于webservice的介绍，本文就不再赘余讲述。详见文章 webservice:(1)新手搭建调用webservice那些坑 首先，先给出一个站点，该站点提供了许多webservice服务，可供调用测试。站点： http://www.webxml.com.cn/zh_cn/index.aspx 如上图所示，我们本文将测试归属地webservice。我们先查询该webservice相关服务。 大家可以在该文本框中输入手机号，userID忽略，点击调用即可查询手机归属地。接下来我们通过代码测试该ws。 注：请求方式有很多种，分别为post、get、soap、wsimport。在这里，使用wsimport方式请求！！！ 步骤1.记录所调用webservice的WSDL进入之前的站点，找到相应webservice，点击服务说明 以下即为相应WSDL，一份xml文档 copy该站点的URL，如下 1http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?WSDL 2.使用JDK目录下的工具-wsimport，生成调用webservice相应的代码wsimport 是一个命令，jdk1.6及以上才可以使用，ws针对不同的语言都会有个wsimport命令，我们可以在自己安装的jdk的bin目录下找到这个 wsimport.exe ，正因为有了这个，所以我们可以在命令行中使用wsimport命令。输入以下命令，会在特定的包中生成java与class文件，接着将其copy至项目路径下即可。 1wsimport -s . -p ws.client.c http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?WSDL Problem：在mac下的终端，若使用到了zsh，可能会出现以下情况。 这是由于 zsh 不兼容的问题！！！具体原因：因为zsh缺省情况下始终自己解释这个 .h，而不会传递给 find 来解释。解决方案：打开 terminal，在~/.zshrc中加入:setopt no_nomatch, 然后进行 *source .zshrc 命令即可 以下为copy入项目空间的示例图注：ws.client.test下的WebserviceTest为webservice测试类，暂时忽略。 这样就有了号码归属地查询这个ws服务相关的API了，且是通过官方的WSDL来生成的。接着，便是编写测试类测试功能了。 3.编写测试类测试1234567891011121314151617package ws.client.test;import ws.client.c.MobileCodeWS;import ws.client.c.MobileCodeWSSoap;public class WebserviceTest &#123; public static void main(String[] args) &#123; //获取一个webservice服务 MobileCodeWS ws = new MobileCodeWS(); //获取具体服务类型：get post soap1.1 and soap1.2 MobileCodeWSSoap wsSoap = ws.getMobileCodeWSSoap(); String address = wsSoap.getMobileCodeInfo(\"你的手机号码\", null); System.out.println(\"手机归属地信息：\"+ address); &#125;&#125; 测试结果示例 OK！！！到这里我们就体验完了该webservice。 总结：webservice中WSDL很重要，里面用xml描述了webservice的信息，所以我们可以通过解析WSDL来获取该webservice相关的API，然后在自己的项目中调用这些API即可调用该webservice。 编程是一门事业。互励共勉！！！ Github：Joryun’s Github CSDN：Joryun’s CSDN 个人网站：Joryun’s Website","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"webservice","slug":"webservice","permalink":"http://joryun.com/tags/webservice/"}]},{"title":"提高Github Clone速度","slug":"github-clone-skill","date":"2017-02-27T13:57:27.000Z","updated":"2017-05-28T02:50:52.000Z","comments":true,"path":"2017/02/27/github-clone-skill/","link":"","permalink":"http://joryun.com/2017/02/27/github-clone-skill/","excerpt":"前言以下操作均在mac下，当然，windows也类似。如题。使用git clone速度之慢，简直绝了。因此，在这里将提出一种较为简单的解决方法，有兴趣花丢丢时间折腾的朋友可以试试。 虽说git clone跟网速离不了干系（有些地区较快，有些地区较慢），但总体来说，大部分都在10KiB/s-20KiB/s之间，及其慢。若是需要clone大repo，那速度简直捉急。","text":"前言以下操作均在mac下，当然，windows也类似。如题。使用git clone速度之慢，简直绝了。因此，在这里将提出一种较为简单的解决方法，有兴趣花丢丢时间折腾的朋友可以试试。 虽说git clone跟网速离不了干系（有些地区较快，有些地区较慢），但总体来说，大部分都在10KiB/s-20KiB/s之间，及其慢。若是需要clone大repo，那速度简直捉急。 解决方案1. 用 git 内置代理，直接走系统中运行的代理工具中转，比如，你的 SS 本地端口是 1080（一般port均为1080），那么可以如下方式走代理：12git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080 编辑.gitconfig文件 Enter之后进入vim，按i进行insert 按Esc退出，输入:wq保存 2. 此外，git clone或者git push特别慢，并不是因为 http://github.com 的这个域名被限制了。而是 http://github.global.ssl.fastly.Net 这个域名被限制了。那么可以在hosts文件里进行绑定映射。具体步骤如下：在terminal输入命令并输入开机密码，Enter确认 1sudo vi /etc/hosts 然后依旧在vim上编辑，命令如下 12151.101.72.249 http://global-ssl.fastly.Net192.30.253.112 http://github.com 保存之后就可以了。 接下来，你可以在clone一次，ssh或https协议都行，速度翻了好几倍！！！ 以下正是亲测的结果，速度已经到达了200多KiB/s！！！ 总结虽说是细节部分，但是随手优化，不仅能接触更多新奇的东西，还能提高效率，何乐而不为呢… 编程是一门事业。互励共勉！！！ Github：Joryun’s Github CSDN：Joryun’s CSDN 个人网站：Joryun’s Website","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"github","slug":"github","permalink":"http://joryun.com/tags/github/"},{"name":"git","slug":"git","permalink":"http://joryun.com/tags/git/"}]},{"title":"Sublime Text 3(Mac版)常用插件篇","slug":"sublimetext-plugin","date":"2017-02-05T08:57:40.000Z","updated":"2017-05-28T02:56:42.000Z","comments":true,"path":"2017/02/05/sublimetext-plugin/","link":"","permalink":"http://joryun.com/2017/02/05/sublimetext-plugin/","excerpt":"前言以下大部份插件Windows安装方法基本与Mac类似.首先，Sublime Text无疑是编程中一款强有力的工具，深受程序猿的喜爱，下面简单介绍下Sublime Text. 说明Sublime Text一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用它来写代码，绝对是一种享受。","text":"前言以下大部份插件Windows安装方法基本与Mac类似.首先，Sublime Text无疑是编程中一款强有力的工具，深受程序猿的喜爱，下面简单介绍下Sublime Text. 说明Sublime Text一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用它来写代码，绝对是一种享受。 接下来直接切入主题，安装过程并不重要，旨在于提高编程效率，因此不会列出众多方法，实在没那个必要.文章的最后提供Sublime Text 3(Mac版)破解版，可直接使用，若链接失效，可私聊. 安装Package Control首先通过快捷键 ctrl+` (~) 或者 View &gt; Show Console 打开控制台(注：安装有QQ输入法的这个快捷键会有冲突的，输入法属性设置-输入法管理-取消热键切换至QQ拼音)，输入以下代码，enter即可. 1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 使用Package Control组件安装插件Cmd+Shift+P（菜单 – Tools – Command Paletter，Windows快捷键：Ctrl+Shift+P），输入 install 选中 Install Package 并回车，输入或选择你需要的插件回车就安装了（注意左下角的小文字变化，会提示安装成功），安装其它插件也类似. 常用插件推荐 Emmet——Emmet 官方提供的 Sublime Text 扩展；//即zencoding，写html先装这一个就够了 SublimeLinter——代码校验插件，支持 HTML、CSS、JS、PHP、Java、C++ 等16种语言； HTML5 Alignment——代码对齐插件 jQuery——代码智能提示插件-Git—整合 Git 功能的插件 LESS——LESS 代码高亮插件 JsFormat——JavaScript 代码格式化插件 LiveReload——让页面即时刷新 Pretty JSON——JSON美化扩展 Can I Use——查询 CSS 属性兼容情况 CoffeeScript——CoffeeScript 代码高亮，校验和编译等 ColorPicker——跨平台取色器插件 Sublime Text 3(Mac版)百度网盘 12URL：https://pan.baidu.com/s/1slW5AUDPassword：rpsu 总结插件可以根据开发类型选择性装特定的插件，毕竟Sublime Text只有拓展插件才能更加优雅地编程。此外，还需要熟记大部份常用的快捷键，才能大大提高编程效率。此文章隶属于教程篇，不足肯定是有的，但只要有钻研精神，相信大家可以在编程路上吸取更多经验。共勉之！！！ 编程是一门事业。互励共勉！！！ Github：Joryun’s Github CSDN：Joryun’s CSDN 个人网站：Joryun’s Website","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://joryun.com/tags/mac/"},{"name":"编辑器","slug":"编辑器","permalink":"http://joryun.com/tags/编辑器/"},{"name":"插件","slug":"插件","permalink":"http://joryun.com/tags/插件/"}]},{"title":"与Bootstrap和CI框架纠缠的三天","slug":"bootstrap-ci-demo","date":"2016-12-31T03:39:35.000Z","updated":"2017-05-28T08:27:43.000Z","comments":true,"path":"2016/12/31/bootstrap-ci-demo/","link":"","permalink":"http://joryun.com/2016/12/31/bootstrap-ci-demo/","excerpt":"前言如题，博主为交附个课程设计，只得用三天时间运用不熟悉的语言完成一个不靠谱的网站开发。一直以来，前台都是自己的硬伤，在平时很少接触bootstrap等优秀的前端框架，而对于我而言，只单单熟悉后台的业务实现，却无法设计出相映衬的前台UI，这点确实是烦恼已久。刚好，趁这次机会，稍微接触下完全不熟悉的bootstrap框架以及许久没用的CI框架，完成一次基本的整合。当然，实现的功能并不复杂，但若是想试下整合，或者想了解下ci框架处理业务方式的朋友，便可以参考下。","text":"前言如题，博主为交附个课程设计，只得用三天时间运用不熟悉的语言完成一个不靠谱的网站开发。一直以来，前台都是自己的硬伤，在平时很少接触bootstrap等优秀的前端框架，而对于我而言，只单单熟悉后台的业务实现，却无法设计出相映衬的前台UI，这点确实是烦恼已久。刚好，趁这次机会，稍微接触下完全不熟悉的bootstrap框架以及许久没用的CI框架，完成一次基本的整合。当然，实现的功能并不复杂，但若是想试下整合，或者想了解下ci框架处理业务方式的朋友，便可以参考下。 系统介绍说明：此次实现的是一个简单的毕业设计选题管理系统，目前是有学生和教师端，基本都是简单整合，无考虑表单重复提交问题，单点登录问题，sql注入等问题。 学生端功能： 查看个人信息 查看公告 查看可选题目(管理员分配教师，学生仅可查看该教师的课题) 查看已选题目 下载资料页面(不全) 教师端功能： 查看公告 查看可选题目 查看学生列表 上传资料页面(不全) 编码(一) Bootstrap框架整合进CIBootstrap：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。 CI：CodeIgniter 是一个小巧但功能强大的 PHP 框架，作为一个简单而“优雅”的工具包，它可以为开发者们建立功能完善的 Web 应用程序。 单从快速开发来说的话，bootstrap+ci确实是很方便，毕竟都是快速开发，而且很容易上手。但由于博主擅长的是j2ee，因此也不过多解释了。严格意义上来说，这两个框架确实只是会用（当然前提是给看官方文档哈哈）. 官网下载ci环境包下载下来的ci环境包内容如下： ci框架的基本配置 解压缩安装包 将 CodeIgniter 文件夹及里面的文件上传到服务器，通常 index.php 文件将位于网站的根目录（ps：博主仅为了练手，因此将其部署于本地服务器，即xampp-htdocs） 使用文本编辑器打开 application/config/config.php 文件设置你网站的根 URL 配置数据库参数，打开application/config/database.php 初步整合 准备好bootstrap demo 将demo的html页面置于ci框架的view层 将js，css，font等资源文件置于_static目录下 修改下主页面css和js的link链接，完成基本的整合 (二) 系统设计界面UI首先，在view层分两文件夹，分别为student和teacher,用于存放各自相应的php文件。 以学生端为示例中间的内容显示内嵌了iframe. Choosable页面 ps：选题按钮还没添加控制器. Selected页面 ps:留言功能还未完善. Data页面 ps:下载文件功能还未完善. 系统基本思路 默认进系统的为Notice页面，即通过控制器load Notice页面. 接着触发Choosable页面，而这过程先是action至该页面的控制器，然后传Choosable所需的数据，并以数组的形式返回，接着在目标页面（即Choosable页面）遍历即可 其余页面的控制思路大同小异，但在form表单action的时候要注意路径问题，一般可调用ci内置的url helper函数获取服务器路径，可避免URL出错 注意 务必按照ci的编程规范编写，否则易出bug 加载数据库，使用url helper以及session等功能，记得在构造函数那儿定义好，这样即可在控制器的全局使用 系统源码详细的源码可访问博主Github：毕业设计选题系统 系统总结博主三天捣鼓的简单整合系统，基本上完成了大致的整合以及一些基本功能，由于时间有限，后续的一些基本功能都没加上，但实现的思路都是类似的。这次为了应付课程设计也是拼了，随便捣鼓了这些原本不是很熟悉的东西，但总体来说还是挺好玩的。有兴趣加入更多模块和安全机制或功能的朋友大可以尝试下，博主仅在玩玩儿哈哈~~~ 新的一年将至，这个就算一个纪念吧！新的一年，博主会着重游走于Github，强化自身项目经验，做出更好的项目与大家一起交流学习，希望新的一年，程序猿们一起共勉！！ 编程是一门事业。互励共勉！！！ Github：Joryun’s Github CSDN：Joryun’s CSDN 个人网站：Joryun’s Website","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"php","slug":"php","permalink":"http://joryun.com/tags/php/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://joryun.com/tags/bootstrap/"},{"name":"codeigniter","slug":"codeigniter","permalink":"http://joryun.com/tags/codeigniter/"}]},{"title":"玩转Spring Boot之Hello World篇","slug":"springboot-helloworld","date":"2016-12-30T13:49:51.000Z","updated":"2017-05-28T02:53:51.000Z","comments":true,"path":"2016/12/30/springboot-helloworld/","link":"","permalink":"http://joryun.com/2016/12/30/springboot-helloworld/","excerpt":"前言玩过Spring全家桶的都知道，Spring家族的框架不仅强大，更是项目构建的好帮手。而接下来，将介绍一款Spring家族的框架——Spring Boot. 关于Spring BootSpring Boot基本概念由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程，并使用“习惯优于配置”的理念让你的项目快速运行起来。使用Spring Boot很容易创建一个独立运行（运行jar，内嵌Servlet容器）、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。","text":"前言玩过Spring全家桶的都知道，Spring家族的框架不仅强大，更是项目构建的好帮手。而接下来，将介绍一款Spring家族的框架——Spring Boot. 关于Spring BootSpring Boot基本概念由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程，并使用“习惯优于配置”的理念让你的项目快速运行起来。使用Spring Boot很容易创建一个独立运行（运行jar，内嵌Servlet容器）、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。 Spring Boot 的优点 开发者快速入门 开箱即用（自带各种默认配置，简化项目配置项） 无冗余代码生成和XML配置文件 搭建Spring Boot 的方式 Eclipse：习惯用Eclipse开发的可使用STS来构建Spring Boot项目 IntelliJ IDEA：推荐的开发工具，功能强大，使用IDEA可直接新建Spring Boot项目 Spring Boot CLI：Spring Boot提供的控制台命令工具 Maven手工构建：构建空的Maven项目，修改pom.xml，增加Spring Boot的依赖包 http://start.spring.io 接下来通过一个简单的Demo来熟悉下Spring Boot项目的基本构建. 编码目的 构建一个基于Maven的Spring Boot项目,并实现一个简单的Http请求处理 了解Spring Boot项目创建,运行过程,项目结构,简单、开发快速的特性 编码1. 创建SpringBoot项目访问：http://start.spring.io/ , 通过SPRING INITIALIZR工具生成基础项目 下载到本地之后，文件夹里的内容如下： 2. 导入IDEA将生成的demo以Maven项目的形式导入IDEA项目结构如下： 3. 引入Web模块新建工程的pom.xml,已经引入了2个依赖模块分别为：spring-boot-starter（核心模块） spring-boot-starter-test（测试模块）接下来需要引入Web模块 : spring-boot-starter-web 添加spring-boot-starter-web配置后，运行maven-&gt;Reimport，更新pom.xml 添加完spring-boot-starter-web后,项目支持web注解基本上有利用SpringMVC开发项目的，很多都接触过注解式开发，而这也是spring的首选开发方式 12@RestControllerRequestMapping(\"/hello\") 4. 添加HelloWord服务在默认生成的com.example包下创建一个web文件夹，并新建一个controller，用于输出“Hello World” 1234567@RestControllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String index()&#123; return \"Hello World\"; &#125;&#125; 5. 启动主程序点击IDEA右上角的启动服务器图标启动主程序 打开浏览器访问 http://localhost:8080/hello ，页面输出Hello World默认启动端口：8080 总结至此，Spring Boot Demo创建完成.有啥问题可以一起讨论哈！！！ 编程是一门事业。互励共勉！！！ Github：Joryun’s Github CSDN：Joryun’s CSDN 个人网站：Joryun’s Website","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://joryun.com/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"http://joryun.com/tags/springboot/"},{"name":"框架","slug":"框架","permalink":"http://joryun.com/tags/框架/"}]},{"title":"webservice:(1)新手搭建调用webservice那些坑","slug":"build-webservice","date":"2016-05-26T05:40:30.000Z","updated":"2017-05-28T02:49:18.000Z","comments":true,"path":"2016/05/26/build-webservice/","link":"","permalink":"http://joryun.com/2016/05/26/build-webservice/","excerpt":"前言今天主要和大家分享搭建java版webservice，以及php调用webservice遇到的一些坑。博客内容大部分纯手打，纯亲测。注：网上有很多使用Eclipse构建webservice的教程，不过配置较麻烦，而且最后可能还访问不了。因此，此博客采用MyEclipse搭建。需注意一点，MyEclipse10及以下的支持不了pattern库，因此发布的项目如果包含Pattern则无法支持，这也是博主换IDE的原因。","text":"前言今天主要和大家分享搭建java版webservice，以及php调用webservice遇到的一些坑。博客内容大部分纯手打，纯亲测。注：网上有很多使用Eclipse构建webservice的教程，不过配置较麻烦，而且最后可能还访问不了。因此，此博客采用MyEclipse搭建。需注意一点，MyEclipse10及以下的支持不了pattern库，因此发布的项目如果包含Pattern则无法支持，这也是博主换IDE的原因。 #说明 开发环境：MyEclipse2014，JAX-WS构建（容易使用），Tomcat 7何为WebService？它是一种构建应用程序的普遍模型,可以在任何支持网络通信的操作系统中实施运行;它是一种新的web应用程序分支，是自包含、自描述、模块化的应用，可以发布、定位、通过web调用。 WebService 是一个应用组件,它逻辑性的为其他应用程序提供数据与服务.各应用程序通过网络协议和规定的一些标准数据格式（Http，XML，Soap)来访问 WebService ,通过 WebService 内部执行得到所需结果. WebService 可以执行从简单的请求到复杂商务处理的任何功能。一旦部署以后，其他 WebService 应用程序可以发现并调用它部署的服务。 关键的技术和规则在构建和使用Web Service时,主要用到以下几个关键的技术和规则: XML:描述数据的标准方法. SOAP:表示信息交换的协议. WSDL:Web服务描述语言. UDDI:通用描述、发现与集成，它是一种独立于平台的，基于XML语言的用于在互联网上描述商务的协议. XML 可扩展的标记语言(XML)是Web service平台中表示数据的基本格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。 SOAP SOAP是web service的标准通信协议，SOAP为simple object access protocoll的缩写，简单对象访问协议. 它是一种标准化的传输消息的XML消息格式。 WSDL WSDL的全称是web service Description Language,是一种基于XML格式的关于web服务的描述语言。其主要目的在于web service的提供者将自己的web服务的所有相关内容,如所提供的服务的传输方式，服务方法接口，接口参数，服务路径等，生成相应的完全文档，发布给使用者。使用者可以通过这个WSDL文档，创建相应的SOAP请求消息，通过HTTP传递给webservice提供者；web服务在完成服务请求后，将SOAP返回消息传回请求者，服务请求者再根据WSDL文档将SOAP返回消息解析成自己能够理解的内容。 UDDI 将web service进行UDDI注册发布,UDDI是一种创建注册表服务的规范,以便大家将自己的web service进行注册发布供使用者查找.然而当服务提供者想将自己的web service向全世界公布，以便外部找到其服务时，那么服务提供者可以将自己的web service注册到相应的UDDI商用注册网站，目前全球有IBM等4家UDDI商用注册网站。因为WSDL文件中已经给定了web service的地址URI，外部可以直接通过WSDL提供的URI进行相应的web service调用。所以UDDI并不是一个必需的web service组件，服务方完全可以不进行UDDI的注册。 具体实例(一) 开始搭建webservice前提首先安装好MyEclipse2014，保证jdk环境配置好了，有tomcat服务器（没有也没关系，MyEclipse自带MyEclipse Tomcat 7，亲测好用，默认端口为8080）。 创建发布webservice 配置Tomcat 部署项目并启动Tomcat服务器 添加JAX-WS库 测试webservice 编码1. 创建发布webservice新建Web Service Project 然后填好信息并next 然后接下来一直next，可选择生成web.xml.这是刚新建的项目结构 2. 然后新建一类文件UserInfo.java 示例源码： 123456789101112131415package com.yuan.webservice;/** * * @author Joryun * */public class UserInfo &#123; public String GetUserInfo()&#123; return \"源哥\"; &#125; public String ParameterTest(String user, String pwd)&#123; return user+\"：\"+pwd; &#125;&#125; 3. 接下来发布web service 4. 选择从java类创建web service 5. 选择访问的java class 6. 生成WSDL（WSDL以上有介绍，不懂可以回去看） 7. 发布后的项目结构如下 (二) 配置Tomcat前提假定你需要使用自己本机Tomcat的情况下 过程Window-Preferences-MyEclipse-Servers-Tomcat 配置好后Apply-OK. 部署项目并启动Tomcat服务器部署此项目到服务器 选择完后Finish 接下来启动Tomcat服务器 服务器已启动的图例 添加JAX-WS库在项目的构建路径中添加库文件 测试webservice输入URL，出现图式效果即为发布成功. 1http://localhost:8080/WebServiceDemo/UserInfoPort?wsdl PHP调用webservice说明博主采用CI框架测试，但不用框架也一样。并且php项目文件发布到了xampp上，直接访问本地即可查看效果。 123关于php调用webservice，亲测过两种方法：1. 引入nusoap.php，调用call()方法2. php5自带函数测试，classMap方式传值 1. 引入nusoap.php，调用call()方法特别注意：以下两处圈红圈的是坑点，一开始测试的时候用的是webservice接口名的参数，即user，pwd.但实际上打印到网页上之后才发现参数是arg0和arg1。。。 2. php5自带函数测试，classMap方式传值 以下贴PHP实现源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpheader('Content-Type: text/html; charset=UTF-8');/** * Class Test * Joryun * * 调用webservice测试类 */class Test extends CI_Controller&#123; public function __construct() &#123; parent::__construct(); &#125; public function index() &#123; /** * nusoap.php需在网上下载，并将该php文件包含进项目空间 * 引入nusoap.php，调用call()方法 */// require_once (\"libs/nusoap.php\");//// // Create the client instance// $client = new nusoap_client('http://localhost:8080/WeixinDemo/UserInfoPort?wsdl', true);// $client-&gt;soap_defencoding = 'utf-8';// $client-&gt;decode_utf8 = false;// $client-&gt;xml_encoding = 'utf-8';//// $param = array('arg0'=&gt;'Joryun', 'arg1'=&gt;'666666');//webservice参数数组// $result = $client-&gt;call('ParameterTest', $param);//接口和参数// print_r($result); /** * php5自带函数测试 * classMap方式传值 */ $client = new SoapClient(\"http://localhost:8080/WeixinDemo/UserInfoPort?wsdl\"); echo (\"SOAP服务器提供的开放Function:\"); echo '&lt;pre&gt;'; var_dump ( $client-&gt;__getFunctions () );//获取服务器上提供的方法 echo '&lt;/pre&gt;'; echo '&lt;br&gt;'; echo (\"SOAP服务器提供的Type:\"); echo '&lt;pre&gt;'; var_dump ( $client-&gt;__getTypes () );//获取服务器上数据类型 echo '&lt;/pre&gt;'; $object=new stdclass; $object-&gt;arg0='Joryun'; $object-&gt;arg1='666666'; $result = $client-&gt;ParameterTest($object); //$result=get_object_vars($result); //将object转换为array var_dump($result); &#125;&#125;?&gt; 总结好了，今天的教程就说到这里了&lt;(￣︶￣)&gt;当然了，之所以想分享是因为其中是有一些坑在，搞了一天多才搞定了。欢迎大家交流，有啥指导直说无妨哈哈哈哈~~ 编程是一门事业。互励共勉！！！ Github：Joryun’s Github CSDN：Joryun’s CSDN 个人网站：Joryun’s Website","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"webservice","slug":"webservice","permalink":"http://joryun.com/tags/webservice/"},{"name":"php","slug":"php","permalink":"http://joryun.com/tags/php/"}]}]}